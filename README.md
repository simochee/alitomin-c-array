# 情報処理IV -演習問題（第６章）-

## 1 １次元配列

### 1.1 １次元配列の宣言と用法

> (1) 要素数が20のint型配列を宣言し、各要素に添え字から 1 を引いた値`(i - 1)`を代入せよ。

```c
// 要素数が20のint型配列を宣言
int a[20];
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 20; i++) {
	// 問題の通り、各要素に (i - 1) を代入する
	a[i] = i - 1;
}
```

> (2) 要素数が25のint型配列を宣言し、各要素に 1,3,5,7,… と順に奇数の値`(2 * i + 1)`を代入せよ。

```c
// 要素数が25のint型配列を宣言
int a[25];
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 25; i++) {
	// 問題の通り、各要素に (2 * i + 1) を代入する
	a[i] = 2 * i + 1;
}
```

> (3) 要素数が30のint型配列を宣言し、各要素にフィボナッチ数列の値を代入せよ
>     ※フェボナッチ数列は1つ前と2つ前の計算結果を足したものを並べた数列

```c
// 要素数が30のint型配列を宣言
int a[30];
// for文で使う変数
int i;

// 0番目と1番目はあらかじめ代入しておく
int a[0] = 0;
int a[1] = 1;

// 要素の数だけ繰り返す
for(i = 2; i < 30; i++) {
	// フェボナッチ数列の性質に従い値を代入する
	a[i] = a[i - 1] + a[i - 2];
}
```

> (4) 要素数が15のdouble型配列を宣言し、各要素に添字に 0.5 を掛けた値`(i * 0.5)`を代入せよ。

```c
// 要素数が15のdouble型配列を宣言
double b[15];
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 15; i++) {
	// 問題の通り、 各要素に (i * 0.5) を代入する
	b[i] = i * 0.5;
}
```

> (5) 要素数が25のdouble型配列を宣言し、各要素に添字に 1 を加算し、さらに 1.1 を掛けた値`( (i + 1) * 1.1)`を代入せよ。

```c
// 要素数が25のdouble型配列を宣言
double b[25];
// for文で使う変数
int i;

// 要素数の数だけ繰り返す
for(i = 0; i < 25; i++) {
	// 問題通り、各要素に ( (i + 1) * 1.1) を代入する
	b[i] = (i + 1) * 1.1;
}
```

> (6) 要素数が10のchar型配列を宣言し、各要素に 'a','b','c'... と順に英小文字`('a' + i)`を代入せよ。

```c
// 要素数が10のchar型配列を宣言
char c[10];
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 10; i++) {
	// 問題通り、各要素に 'a' + i を代入する
	c[i] = 'a' + i;
}
```

#### アルファベットに数字を足す？

C言語はすべての文字に固有の数値が割り振られている（例：'a': 97、'b': 98、'c': 99）。

つまり'a'は内部的に97と同じ値になる。そのため、'a'に1を加えると98つまり'b'となる。

この文字と数値の対応は以下のリンクを参照。

[ASCIIコード表](http://www9.plala.or.jp/sgwr-t/c_sub/ascii.html)

> (7) 要素数が26のchar型配列を宣言し、各要素に 'Z','Y','X',… と逆順に英大文字`('Z' - i)`を代入せよ。

```c
// 要素数が26の配列を宣言
char c[26];
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 26; i++) {
	// 問題通り、各要素に 'Z' - i を代入する
	c[i] = 'Z' - i;
}
```

> (8) 要素数が26のchar型配列を宣言し、各要素に 'X','Y','Z','A','B',… と順に英大文字`('a' + (i + 23) % 26)`を代入せよ
> （アルファベットを３文字分左にシフトさせる。もしくは23文字右にシフトさせる）。

```c
// 要素数が26の配列を宣言
char c[26];
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 26; i++) {
	// 問題通り、各要素に ('a' + (i + 23) % 26) を代入する
	c[i] = ('a' + (i + 23) % 26);
}
```

### 1.2 １時配列の応用

```c
double data[10] = {5.6, 8.1, 4.6, 7.6, 7.3, 8.8, 5.3, 9.6, 6.8, 7.3};
```

> (1) 配列に格納されている全要素の値の合計および平均値を求めよ。

```c
// 配列を宣言・定義
double data[10] = {5.6, 8.1, 4.6, 7.6, 7.3, 8.8, 5.3, 9.6, 6.8, 7.3};

// 合計値を保存する変数
double sum = 0;
// 平均値を保存する変数
double avl;
// for文で使う変数
int i;

// 要素の数だけ繰り返す
for(i = 0; i < 10; i++) {
	// 変数sumに要素の値を加える
	// sum = sum + data[i];
	sum += data[i];
}

// この時点でsumには配列の合計値が入っている

// 平均値は合計値を要素数で割ればよい
avl = sum / 10;

// sum: 71.0
// avl: 7.1
```

> (2) 配列に格納されている全要素の値の最小値および最大値を求めよ。

```c
// 配列を宣言・定義
double data[10] = {5.6, 8.1, 4.6, 7.6, 7.3, 8.8, 5.3, 9.6, 6.8, 7.3};

// 最小値を保存する変数(最初の変数を最小値とする)
double min = data[i];
// 最大値を保存する変数(最初の要素を最大値とする)
double max = data[i];
// for文で使う変数
int i;

/*
 * 最小値を求める
 */
// 要素の数だけ繰り返す
for(i = 1; i < 10; i++) {
	// 現在の最小値より今の要素の値が小さければ
	if(min > data[i]) {
		// minに要素の値を代入する
		min = data[i];
	}
}

// この時点で変数minには配列dataの最小値が入っている
// min: 4.6

/*
 * 最大値を求める
 */
// 要素の数だけ繰り返す
for(i = 1; i < 10; i++) {
	// 現在の最大値よりも今の要素の値が大きければ
	if(max < data[i]) {
		// maxに要素の値を代入する
		max = data[i];
	}
}

// この時点で変数maxには配列dataの最大値が入っている
// max: 9.6
```

> (3) 同じ要素数の配列`copy`を宣言し、配列`data`の各要素の値を配列`copy`にコピーせよ。

```c
// 配列を宣言・定義
double data[10] = {5.6, 8.1, 4.6, 7.6, 7.3, 8.8, 5.3, 9.6, 6.8, 7.3};

// 配列をコピーするための要素数10の配列を宣言
double copy[10];
// for文で使う変数
int i;

/*
 * コピー => 配列dataの各要素を配列copyの同じ場所に代入する
 */
// 要素の数だけ繰り返す
for(i = 0; i < 10; i++) {
	// 要素を代入
	copy[i] = data[i];
}

// この時点でcopyはdataと同じ要素の配列になっている
```

> (4) 同じ要素数の配列`reverse`を宣言し、配列`data`の各要素の値を逆順に配列`reverse`にコピーせよ。

```c

// 配列を宣言・定義
double data[10] = {5.6, 8.1, 4.6, 7.6, 7.3, 8.8, 5.3, 9.6, 6.8, 7.3};

// 配列をコピーするための要素数10の配列を宣言
double reverse[10];
// for文で使う変数
int i;

/*
 * 逆順にコピー => 配列dataの各要素を配列reverseの後ろから数えて同じ場所に代入する
 */
// 要素の数だけ繰り返す
for(i = 0; i < 10; i++) {
	// 要素数 - iの場所に代入
	reverse[10 - i] = data[i];
}

// この時点でreverseはdataの逆順の配列になっている
```

> (5) 配列の各要素に格納されている値の個数だけ"*"を横に並べて表示せよ。

```c
int data[8] = {5, 4, 8, 6, 0, 3, 2, 6};
```

```c
// 配列を宣言・定義
int data[8] = {5, 4, 8, 6, 0, 3, 2, 6};

// for文で使う変数
int i, j;

// 要素の数だけ繰り返す
for(i = 0; i < 8; i++) {
	// 要素の値だけ繰り返し"*"を出力する
	for(j = 0; j < data[i]; j++) {
		// "*"を出力
		printf("*");
	}
	// 改行を出力
	printf("\n");
}
```

